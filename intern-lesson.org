
* Scope

It's ugly and complicated, but here's all you really need to know.

Global stuff goes in the k-tree. It's just a big nested dictionary.

You can change your location in the tree with =\d= and query it with =_d=.

Functions run in the current directory, not the one where they were defined:

#+begin_src k
  .d.i: 100
  .d.set:{i::x}
  .d.get:{i}
  .d.set 123
  .d.get `
123
  .d.i
100
  i
123
#+end_src


Closures work, but only one level deep.

#+begin_src k
  {n:123; {m:101; {(n;m)}}}[`][`][`]
(;101)
#+end_src

- so if you need nested closures, pass everything you want to close over explicitly.
- you can use =x::123= to assign globals, but probably shoudn't.
- instead use =.path.to.x: 123=
- pass a symbol containing a path to use an arbitrary scope.


* Arrays as functions

Most obvious example is a lookup table: it just maps the natural numbers up to =#a= to an item in =a=:

#+begin_src k
sqr:  0 1 4 9 25 36 49 64 81 100 # squares for domain !11
#+end_src

If you construct it dynamically, that's just memoization.

#+begin_src k
  fibs: 1 1
  fib: {while[x>-1+#fibs; fibs:: fibs,+/-2#fibs]; fibs x}
  fib 12
233
  fibs
1 1 2 3 5 8 13 21 34 55 89 144 233
#+end_src

Basically what we're doing is using the array to configure a specific function, which acts as an interpreter. In this case it's the index function:

#+begin_src k
  @[fibs; 7]
21
  @["abcdefghijklmnop"; 7]
"h"
#+end_src

But we could use another interpreter.

#+begin_src k
  p: {+/x*y^!#x}

  _ p[|1 0 1 0; 10]
1010

  _ p[|1 0 1 0;  2]
10

#+end_src


(Any guesses what this does?)

One way to think of this function is that evaluating the digits "0 1 0 1" in some base.

Or you could say it's evaluating the polynomial /x^3+x/.

This is such a handy function that it's built in, as =_sv=.

#+begin_src k
  p[1 2 0 ; 5]
35.0
  5 _sv 1 2 0
35
#+end_src


Let's refactor a bit:

#+begin_src k
  dot: {+/x*y}
  p: {dot[x; y^|!#x]}
  p[1 2 3 4; 10]
#+end_src


I'm calling this dot because we're multiplying two vectors to get a scalar, and that's called a dot product in algebra.

But because of the way conformance works in K, the dot product actually handles any combination of vectors and matrices. For example, here's an identity matrix:

#+begin_src k
  Im: {{x=/:x}@!x};  Im 4
(1 0 0 0
 0 1 0 0
 0 0 1 0
 0 0 0 1)
#+end_src


So this dot function also performs vector-matrix multiplication:


#+begin_src k
  dot[Im 4; 1 2 3 4 ]
1 2 3 4
  dot[1 2 3 4; Im 4 ]
1 2 3 4
#+end_src

If we want a matrix product, we can use eachright:

#+begin_src k
  dot[Im 4; Im 4]
1 1 1 1

  dot/:[Im 4; Im 4]
(1 0 0 0
 0 1 0 0
 0 0 1 0
 0 0 0 1)
#+end_src

You can do the same thing with vectors to get various other sorts of products. Eachright and eachleft together give you cross products:

#+begin_src k
  dot\:/:[2 3 5; 7 11]
(14 21 35
 22 33 55)

  dot/:\:[2 3 5; 7 11]
(14 22
 21 33
 35 55)
#+end_src

So combined with this little interpreter, we can represent all sorts of interesting functions just by feeding it different arrays. For example, suppose we made an array like this:

#+begin_src k
  Dm:{1!'(!x)*Im x}

  Dm 4
(0 0 0 0
 1 0 0 0
 0 2 0 0
 0 0 3 0)
#+end_src

... And if /f/ is an vector representing a polynomial, then using dot of f with a matrix like that gives you back the derivative of f.

#+begin_src k
  Dm 4
(0 0 0 0
 1 0 0 0
 0 2 0 0
 0 0 3 0)

  f: 2 3 5 7            / 2 + 3x + 5x^2 + 7x^3

  dot[Dm[#f]] f
3 10 21 0
#+end_src


Now suppose you have a matrix like this:

#+begin_src k
  m: {x=/:(!#x)} 5 2 1 0 4 3
  m
(0 0 0 1 0 0
 0 0 1 0 0 0
 0 1 0 0 0 0
 0 0 0 0 0 1
 0 0 0 0 1 0
 1 0 0 0 0 0)
#+end_src


Any matrix like this, that just has a single one in every row and column, is a permutation matrix, and interpreting it with dot gives you back a function that permutes its input vector:

#+begin_src k
  dot[m] 2 3 5 7 11 13
13 5 3 2 11 7
#+end_src

But actually we could have done the same thing with the vector we used to create that matrix:

#+begin_src k
  a: 2 3 5 7 11 13
  v: 5 2 1 0 4 3

  dot[m] a
13 5 3 2 11 7

  a v
13 5 3 2 11 7
#+end_src

This is called a permutation vector.

If you use it on the left side of the at sign, then it's just a lookup table that tells you what order to put things in.

#+begin_src k
  v @ 0 1 2
5 2 1
#+end_src

Here, =v 0= is 5, so that says item 0 goes in slot 5, item 1 goes in slot 2, item 2 goes in slot 1, and so on.

On the right hand side of the at sign, it acts like a function that permutes whatever's on the left:

#+begin_src k
  "tae!on" @ v
"neato!"
#+end_src

How did I figure out which scrambled string to use there?

Permuting a permutation vector gives you another permutation vector. If you keep doing that, eventually it will cycle around:

#+begin_src k
  6 v\v
(5 2 1 0 4 3
 3 1 2 5 4 0
 0 2 1 3 4 5
 5 1 2 0 4 3
 3 2 1 5 4 0
 0 1 2 3 4 5
 5 2 1 0 4 3)
#+end_src


So if you can see the cycle length is 6, then you could just permute the identity permutation vector (bang) five times:

#+begin_src k
  "neato!" @ 5 v/!6
"tae!on"
#+end_src

But there's an easier way:

#+begin_src k
  v
5 2 1 0 4 3
  <v
3 2 1 5 4 0
  v@<v
0 1 2 3 4 5
#+end_src

The grade operator gives you a permutation vector. If your input is sorted, then grading it gives you back the identity permutation.

This means the grade of a permutation vector is the inverse permutation.

#+begin_src k
"tae!on"
  m: "neato!" @ <v
  m
"tae!on"

  m v
"neato!"
#+end_src

A permutation vector can be used over and over again on many different arrays of the same length.

This lets us do interesting things, like grading a column in a table, and using the resulting permutation vector to sort not only that column, but other columns in that table as well.

(and then show some live demos)

