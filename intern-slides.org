#+STARTUP: beamer

* Arrays as Functions

* But First... Scope.
** Scope: The basics
It's ugly and complicated, but here's all you really need to know.

- Global stuff goes in the k-tree. It's just a big nested dictionary.

- You can change your location in the tree with =\d= and query it with =_d=.

** Scope: functions and the k-tree

Functions run in the current directory, not the one where they were defined:

#+begin_src k
  .d.i: 100
  .d.set:{i::x}
  .d.get:{i}
  .d.set 123
  .d.get `
123
  .d.i
100
  i
123
#+end_src

** Scope: closures

Closures work, but only one level deep.

#+begin_src k
  {n:123; {m:101; {(n;m)}}}[`][`][`]
(;101)
#+end_src

so if you need nested closures, pass everything you want to close over explicitly.

** Scope: misc

- you can use =x::123= to assign globals, but probably shoudn't.
- instead use =.path.to.x: 123=
- pass a symbol containing a path to use an arbitrary scope.


* Arrays as functions

** goal: fib
*** Memoization

#+begin_src k
  fibs: 1 1
  fib: {while[x>-1+#fibs; fibs:: fibs,+/-2#fibs]; fibs x}
  fib 12
233
  fibs
1 1 2 3 5 8 13 21 34 55 89 144 233
#+end_src

** goal: choose[k;n]

Cnk: 52 (1,,[;1]@+':)\ 1


** goal: h2d
*** char to number
*** powers of 16
#+begin_src k
  {x* _16^!#x}
  {x* */1,1_(#x)#16]}
#+end_src
*** powers of 10?
*** projection!
*** _sv

#+begin_src k
  p[1 2 0 ; 5]
35.0
  5 _sv 1 2 0
35
#+end_src



** polynomials
*** simple examples

/ +/  _ x⁰, _ x¹, _ x², _ x³
_sv[  0     0     0     0 ; i: !10 ]
_sv[  0     0     0     0 ; i ]
_sv[  0     0     0     0 ; i ]
_sv[  0     0     0     0 ; i ]


** goal: take the derivative

*** calculus refresher

*** derivatives

#+begin_src k
  Dm:{1!'(!x)*Im x}

  Dm 4
(0 0 0 0
 1 0 0 0
 0 2 0 0
 0 0 3 0)
#+end_src

*** Dm in action!

#+begin_src k
  Dm 4
(0 0 0 0
 1 0 0 0
 0 2 0 0
 0 0 3 0)

  f: 2 3 5 7            / 2 + 3x + 5x^2 + 7x^3

  dot[Dm[#f]] f
3 10 21 0
#+end_src



** dot product: matrices
*** identity matrix
#+begin_src k
/  Im: {{x=/:x}@!x};  Im 4
   Im: {v=/:v:!x};  Im 4
(1 0 0 0
 0 1 0 0
 0 0 1 0
 0 0 0 1)
#+end_src

:  Im: {v=/:v:!x};  Im 4

*** general tables
#+begin_src k
  tb: {[f;x] v (f/:) v:!x}

  tb[+;4]
#+end_src

*** matrix as dyad
#+begin_src k
  mul: v */: v:!10
  mul[ 3; 6 ]
  mul/ 7 2
#+end_src

*** state machine!
#+begin_src k

#+end_src

** goal: integration

** goal: permutations
*** Another fine matrix

#+begin_src k
  m: {x=/:(!#x)} 5 2 1 0 4 3
  m
(0 0 0 1 0 0
 0 0 1 0 0 0
 0 1 0 0 0 0
 0 0 0 0 0 1
 0 0 0 0 1 0
 1 0 0 0 0 0)
#+end_src

** permutation matrix

#+begin_src k
  m
(0 0 0 1 0 0
 0 0 1 0 0 0
 0 1 0 0 0 0
 0 0 0 0 0 1
 0 0 0 0 1 0
 1 0 0 0 0 0)

  m (+/*) 2 3 5 7 11 13
13 5 3 2 11 7
#+end_src

** permutation vector

#+begin_src k
  a: 2 3 5 7 11 13
  v: 5 2 1 0 4 3

  dot[m] a
13 5 3 2 11 7

  a v
13 5 3 2 11 7
#+end_src

** permutation vectors
#+begin_src k
  v: 5 2 1 0 4 3
  v @ 0 1 2
5 2 1
#+end_src

** permutation vectors
#+begin_src k
  v: 5 2 1 0 4 3
  "tae!on" @ v
"neato!"
#+end_src

** permutation vectors
#+begin_src k
  v: 5 2 1 0 4 3
  "tae!on" @ v
"neato!"
#+end_src

How did I figure out which scrambled string to use there?

** permutation powers
#+begin_src k
  6 v\v
(5 2 1 0 4 3
 3 1 2 5 4 0
 0 2 1 3 4 5
 5 1 2 0 4 3
 3 2 1 5 4 0
 0 1 2 3 4 5
 5 2 1 0 4 3)
#+end_src

** one less than the cycle length
#+begin_src k
  "neato!" @ 5 v/!6
"tae!on"
#+end_src

** an easier way

#+begin_src k
  v
5 2 1 0 4 3
  <v
3 2 1 5 4 0
  v@<v
0 1 2 3 4 5
#+end_src

** grade as inverse

The grade of a permutation vector is the inverse permutation.

#+begin_src k
"tae!on"
  m: "neato!" @ <v
  m
"tae!on"

  m v
"neato!"
#+end_src

* mini-db demo

* a mystery function

#+begin_src k
  f: {&2=#:'&:'+{0,n#(x#0),1}@/:!n:x}

  f 3
2 3
#+end_src

* mystery function, take 2

#+begin_src k
  /  {&2=#:'&:'+{0,n#(x#0),1}@/:!n:x}

  f: {&2=+/{0,n#&x,1}@/:!n:x}

  f 3
2 3
#+end_src

* mystery function, take 3

#+begin_src k
  /  {&2=#:'&:'+{0,n#(x#0),1}@/:!n:x}
  /  {&2=+/{0,n#&x,1}@/:!n:x}

  f: {&2=+/{0,n#&x,1}'!n:x}

  f 3
2 3
#+end_src

